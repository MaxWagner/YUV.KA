\subsection{\name{YuvKA.VideoModel}}

\paragraph{\name{Frame}}
\begin{itemize}
	\add \verb!public GetPixelOrBlack(int x, int y)! \\
	Neue öffentliche Methode, die es erleichtern soll, auf die Farbwerte innerhalb eines Frames zuzugreifen, ohne beachten zu müssen, ob die gegebenen Koordinaten tatsächlich innerhalb des \name{Frame} liegen. Falls ja, so wird der entsprechende Pixel an Stelle (x, y) als \name{Rgb}-Objekt zurückgegeben. Falls nicht, so wird ein schwarzer Farbwert für den Pixel zurückgegeben.
	\add \verb!public MaxBoundaries(Frame[] frames)! \\
	Neue öffentliche Methode, welche aus einem Array von Frames jeweils das Maximum der Breite und der Höhe findet und ein \name{Size}-Objekt zurückgibt mit \name{height}- bzw. \name{width}-Wert, welcher alle gegebenen Frames umfasst.
\end{itemize}

\paragraph{\name{MacroblockDecision}}
\begin{itemize}
	\change \verb!public Vector Movement { get; set; }! \\
	Die \name{Movement}-property wurde schreibbar gemacht, da eine korrekte Initialisierung sonst nicht möglich wäre.
	\change \verb!public MacroblockPartitioning? Partitiondecision { get; set; }! \\
	Die \name{Partitiondecision}-property wurde schreibbar gemacht, da eine korrekte Initialisierung sonst nicht möglich wäre.
\end{itemize}

\paragraph{\name{Rgb}}
\begin{itemize}
	\change \verb!public byte R { get; private set; }! \\
	Der setter der R-Property wurde auf private gesetzt.
	\change \verb!public byte G { get; private set; }! \\
	Der setter der G-Property wurde auf private gesetzt.
	\change \verb!public byte B { get; private set; }! \\
	Der setter der B-Property wurde auf private gesetzt.
\end{itemize}

\paragraph{\name{YuvEncoder}}
\begin{itemize}
	\add \verb!public static Video Decode(int width, int height, string filename, string logFileName = null, string motionVectorFileName = null)! \\
	Neuer Parameter \verb!string motionVectorFileName = null!: Die an ein Video gebundenen Bewegungsvektoren sollen schon beim Lesen eines Videos vom Hintergrundspeicher gelesen werden, da \name{Video}-Obekte unveränderlich sind, und bei Neuwahl der entsprechenden Datei ein neues Video-Objekt erstellt werden muss.
	\add \verb!public static void Encode(Stream stream, IEnumerable<Frame> frames)! \\
	Neue öffentliche statische Methode Encode, welche als Parameter einen Stream entgegennimmt. Dies ermöglicht es, zu Testzwecken auch in einen \name{MemoryStream} zu schreiben, was den Hintergrundspeicher nicht belastet und in der Regel schneller ist.
\end{itemize}

\paragraph{\name{YuvEncoder.Video}}
\begin{itemize}
	\remove \verb!public void Dispose()! \\
	Da keine Streams länger als unbedingt nötig offen gehalten werden, ist die zuvor von der \name{Video}-Klasse implementierte Schnittstelle \name{IDisposable} hier nicht mehr benötigt. Dadurch entfällt diese Methode.
\end{itemize}


\subsection{\name{YuvKA.Pipeline}}

\paragraph{\name{InputNode}}
\begin{itemize}
	\change \verb!public int? TickCount! \\
	Die Property \verb!TickCount! ist nun nullable. Der Wert null steht hierbei für die Möglichkeit (theoretisch) unendlich viele Frames zu erzeugen.
\end{itemize}

\paragraph{\name{Node}}
\begin{itemize}
	\change \verb!public Node(int? inputCount, int? outputCount)! \\
	Die Parameter des Konstruktors sind jetzt nullable, um mit dem Wert null eine Variable Anzahl von Ein-/Ausgängen zu repräsentieren.
	\add \verb!public virtual bool InputIsValid { get; }! \\
	Diese Property wurde eingeführt, um repräsentieren zu können, ob alle Inputs des Knotens (indirekt) mit InputNodes verbunden sind und der Knoten somit seine Berechnung auch ausführen kann.
	\add \verb!public string Name { get; set; }! \\
	Repräsentiert den Namen des Knoten. Der Name eines Knoten ist eine möglichst kurze Beschreibung der Funktionsweise des Knotens. Im Idealfall ist diese Beschreibung nur ein Wort lang.
	\add \verb!public virtual int NumberOfFramesToPrecompute { get; }! \\
	Wurde eingeführt, da manche Knoten Daten aus vergangenen Ticks zur Berechnung des aktuellen Ticks brauchen. Damit diese Knoten auch nach dem Springen in der Pipeline das korrekte Ergebnis liefern, muss man eventuell Ticks vorberechnen. Diese Property repräsentiert, wie viele vergangene Frames der Knoten kennen muss, um seine Berechnung auszuführen.
	\add \verb!public virtual bool OutputHasLogfile { get; }! \\
	Wurde eingeführt, um repräsentieren zu können, ob die Ausgabe des Knotens Logfiles beinhaltet.
	\add \verb!public virtual bool OutputHasMovementVectors { get; }! \\
	Wurde eingeführt, um repräsentieren zu können, ob die Ausgabe Movement-Vektoren beinhaltet.
	\add \verb!public virtual bool UserCanAddInputs { get; }! \\
	Diese Property gibt an, ob der User in der Lage sein soll Inputs zu diesem Knoten hinzuzufügen.
	\remove \verb!public void Dispose()! \\
	Die Methode \verb!Dispose()! wurde entfernt, da keine Streams mehr offen gehalten werden.
\end{itemize}

\paragraph{\name{Node.Input}}
\begin{itemize}
	\remove \verb!public int Index { get; }! \\
	Wurde entfernt, da es nicht mehr gebraucht wurde und Node.Input keinen Zugriff auf seinen Knoten hat und daher seinen Index auch nicht berechnen kann.	
\end{itemize}

\paragraph{\name{PipelineDriver}}
\begin{itemize}
	\change Die Klasse ist nicht mehr als statisch deklariert. Diese Änderung ermöglicht, verschiedene Graphen parallel zu berechnen, indem jeweils ein Driver instanziert wird, die einzelnen Berechnungen aber weiterhin den Parallelitätszusicherungen genügen.
	\add \verb!public IObservable<IDictionary<Node.Output, Frame>> RenderTicks(IEnumerable<Node> startNodes, int startTick = 0, int? tickCount = null, CancellationToken? token = null)! \\
	Neuer Parameter \verb!int? tickCount = null!: Wie sich herausstellte, sollte die Berechnung der Pipeline nicht nur durch ein \name{CancellationToken} jederzeit abbrechbar sein, sondern auch von sich aus nach einer gegebenen Anzahl Ticks, nämlich bis zum Ende des gegebenen Eingabevideos, enden können. Existiert kein Eingabevideo, kann dem Parameter \name{null} zugewiesen werden (der Standardwert), um weiterhin bis zu einem manuellen Abbruch zu berechnen.
\end{itemize}

\paragraph{\name{PipelineGraph}}
\begin{itemize}
	\change \verb!public int? TickCount { get; }! \\
	Die Property ist nun ein nullable int, da der Wert Null verwendet wird, um eine unbegrenzte Videolänge zu signalisieren.
	\add \verb!public void AddNode(Node node)! \\
	Diese Erweiterung ermöglicht es beim Hinzufügen eines Knoten diesem einen eindeutigen Namen aus der Folge Defaultname, Defaultname 2, Defaultname 3, ... zuzuordnen. Dieser Name kann nun verwendet werden, um ihn im Knoten selbst und allen seinen zugehörigen Outputfenstern anzuzeigen. Hiermit steht dem Benutzer eine leiche erkennbare eindeutige Zuordnung zur Verfügung. Weiterhin sollten auf keine andere Weise Knoten zum Graphen hinzugefügt werden.
	\add \verb!public bool CanAddEdge(Node source, Node sink)! \\
	Die Abfrage, ob eine Kante legal ist, ohne sie auch hinzuzufügen, ermöglicht es, Kanten in der GUI schon vor dem Drop-Event als legal oder illegal zu markieren.
	\add \verb!public int NumberOfFramesToPrecompute(IEnumerable<Node> outputNodes)! \\
	Da es möglich sein soll in der Pipeline zu springen und es Knoten gibt, die den aktuellen Frame aus vergangenen Ticks berechnen, muss hierzu errechnet werden wie viele Ticks vorberechnet werden sollen.
	\add \verb!public void RemoveNode(Node node)! \\
	Es stellte sich heraus, dass beim Entfernen eines Knoten aus dem Graphen auch alle zugehörigen Kanten entfernt werden müssen. Diese neue Methode ermöglicht dies.
\end{itemize}

\paragraph{\name{PipelineState}}
\begin{itemize}
	\add \verb!public int ActualSpeed { get; }! \\
	Besonders zu Debugzwecken und zur Demonstration wurde diese Property hinzugefügt, um die tatsächlich gemessene Abarbeitungsgeschwindigkeit in der UI anzeigen zu können.
	\add \verb!public PipelineDriver Driver { get; }! \\
	Nachdem in der \name{PipelineDriver}-Klasse der \name{static}-Modifier entfernt wurde, musste mit dieser neuen Property der Pipeline eine Driver-Instanz zugeordnet werden.
\end{itemize}


\subsection{\name{YuvKA.Pipeline.Implementation}}

\paragraph{\name{AveragedMergeNode}}
\begin{itemize}
	\change Wurde zu WeightedAveragedMergeNode umbenannt, da es die Funktion des Knotens besser beschreibt.
\end{itemize}

\paragraph{\name{NoiseInputNode}}
\begin{itemize}
	\add \verb!public double? Scale { get; set; }! \\
	Diese neu eingeführte Option erlaubt es dem Benutzer den angezeigten Perlin Noise zu skalieren.
	\add \verb!public double? Speed { get; set; }! \\
	Diese neu eingeführte Option erlaubt es dem Benutzer die Geschwindigkeit des angezeigten Perlin Noise einzustellen.
\end{itemize}

Desweiteren wurden zwei neue Arten von Noise eingeführt, die Abwandlungen der schon existierenden sind (siehe \name{NoiseType}).

\paragraph{\name{NoiseType}}
\begin{itemize}
	\add \verb!ColoredCoherent! \\
	Erstellt farbigen Coherent Noise.
	\add \verb!ColoredPerlin! \\
	Erstellt farbigen Perlin Noise.
\end{itemize}

\paragraph{\name{DiagramGraph}}
\begin{itemize}
	\change \verb!public IList<KeyValuePair<int, double>> Data { get; set; }! \\
	Der Liste wurde jeweils der Tick des zugehörigen Analysedatums hinzugefügt.
\end{itemize}

\paragraph{\name{IGraphType}}
\begin{itemize}
	\add \verb!bool DependsOnAnnotatedReference { get; }! \\
	Ruft ab, ob der Diagrammtyp ein Referenzvideo mit Logfile benötigt.
	\add \verb!bool DependsOnLogfile { get; }! \\
	Ruft ab, ob der Diagrammtyp ein Logfile benötigt.
\end{itemize}

\paragraph{\name{HistogramNode}}
Die zur Berechnung des jeweiligen Histogrammtyps benötigten Methoden wurden als private Methoden ausgelagert.

\paragraph{\name{OverlayNode}}
\begin{itemize}
	\add \verb!public Frame Data { get; private set; }! \\
	Eine Schnittstelle durch die andere Klassen das Resultat der Überlagerung abgreifen können. Dies ist notwendig, da die \name{View} die \name{Process} Methode nicht selbst aufruft.
	\add \verb!public OverlayViewModel Window { get; }! \\
	Ruft das \name{OverlayViewModel}, welches zu diesem Knoten gehört, auf bzw. erstellt es. Dies ist notwendig, da die \name{View} wissen muss dass dieser Knotentyp, eine eigene Ausgabefensterart besitzt und sich dies mit einem entsprechenden \name{ProperyViewModel} ohne schwerwiegende Architektureingriffe sehr gut verwirklichen lässt.
\end{itemize}

\paragraph{\name{IOverlayType}}
\begin{itemize}
	\add \verb!bool DependsOnReference { get; }! \\
	Eine Wahrheitsvariable die wiedergibt, ob die Überlagerungsart auf eine Referenz angewiesen ist.
	\add \verb!bool DependsOnVectors { get; }! \\
	Eine Wahrheitsvariable die wiedergibt, ob die Überlagerungsart auf Bewegungsvektordaten angewiesen ist.
\end{itemize}

\paragraph{\name{+ NoOverlay}}~\\
Diese Klasse ist ein Überlagerungstyp der nichts überlagert und somit stets verfügbar ist, unabhängig von den zusätzlichen Daten neben der obligatorischen ursprünglichen \name{Frame}.

\subsection{\name{YuvKA.ViewModel}}

Wie erwartet hat sich im Viewmodel eine große Zahl an Änderungen ergeben, die zum Großteil aus dem Hinzufügen neuer Properties bestehen. Dies ist besonders der Tatsache geschuldet, dass das Viewmodel nicht wirklich Teil der grundlegenden Architektur sondern vielmehr Verknüpfungsschicht des Models und der View ist, wobei die Architektur letztgenannter Schicht, nämlich WPF, bereits gegeben war und wegen ihres unglaublichen Umfangs im Detail erst während der Implementierung Fall für Fall exakt erkundet werden konnte. Deshalb werden im Weiteren die Änderungen beschrieben, ohne einzeln auf die Gründe einzugehen, warum von der Entwurfsarchitektur abgewichen wurde.

\paragraph{\name{EdgeViewModel}}
\begin{itemize}
	\add \verb!public InOutputViewModel StartViewModel { get; set; }! \\
	     \verb!public InOutputViewModel EndViewModel { get; set; }! \\
	Legt Anfang bzw. Ende der Kante auf einen Ein-/Ausgang fest. Nach Setzen der Properties werden Start- bzw. Endpunkt der Kante automatisch entsprechend aktualisiert.
	\add \begin{verbatim}public EdgeStatus Status { get; set; }
	enum EdgeStatus { Indeterminate, Invalid, Valid }
	\end{verbatim}
	Gibt während des Ziehens einer Kante ihren Zustand an, der in der View durch die Linienfarben schwarz/rot/grün visualisiert wird.
	\add \verb!public void Dispose()! \\
	Entfernt alle Abonnements von Positionsänderungen der verbundenen Knoten, um Speicherlecks zu verhindern.
\end{itemize}

\paragraph{\name{+ InOutputViewModel}}~\\
\name{InOutputViewModel} ist eine gemeinsames View Model für Inputs und Outputs.
\begin{itemize}
	\add \verb!public bool IsFake { get; }! \\
	Fake-Eingänge sind solche ohne zugrundeliegendes Model. Sie werden für das dynamische Hinzufügen von Eingängen benötigt.
	\add \verb!public IObservable<Point> Midpoint { get; }! \\
	Gibt den gerade jeweils aktuellen Mittelpunkt des Ein-/Ausgangs zurück.
	\add \verb!public object Model { get; }! \\
	Der zugrundeliegende Input oder Output
	\add \verb!public NodeViewModel Parent { get; }! \\
	Das View Model des Knotens dieses Ein-/Ausgangs
\end{itemize}

\paragraph{\name{MainViewModel}}
\begin{itemize}
	\add \verb!public void CloseWindows(Node node)! \\
	Erzwingt das Schließen aller Ausgabefenster dieses Knotens
	\add \verb!public void Handle(OutputWindowViewModel.ClosedMessage message)! \\
	Reagiert auf das Schließen eines Fensters.
	\verb!public void Handle(ChangeCommittedMessage message)! \\
	Reagiert auf in sich abgeschlossene Wertänderungen von Knoten-Properties.
\end{itemize}

\paragraph{NodeViewModel}
\begin{itemize}
	\add \verb!public bool HasOutputs { get; }! \\
	Gibt an, ob der Knoten derzeit Ausgänge besitzt.
	\add \verb!public IEnumerable<InOutputViewModel> Inputs { get; }! \\
	\verb!public IEnumerable<InOutputViewModel> Outputs { get; }! \\
	Wrappen die Ein-/Ausgänge des Knotens in enstprechende View Models.
	\add \verb!public Thickness Margin { get; }! \\
	Gibt die durch \name{Position} angegebene Verschiebung View-verträglich zurück.
	\add \verb!public Point Position { get; set; }! \\
	Zusammenfassung des \name{X}- und \name{Y}-Wertes des Knotens
	\add \verb!public IObservable<Unit> ViewPositionChanged { get; }! \\
	Beobachtbare Sequenz von Events, in der jeder Eintrag für die Veränderung der tatsächlichen Position auf der View steht.
	\add \verb!public int ZIndex { get; set; }! \\
	Regelt die Zeichenabfolge von Knoten, damit der letztausgewählte Knoten nicht von anderen verdeckt ist.
	\add \verb!public void AddInput()! \\
	Fügt bei dynamisch um Eingänge erweiterbaren Knoten einen neuen Eingang hinzu.
	\add \verb!public void RemoveNode()! \\
	Entfernt diesen Knoten aus allen relevanten Listen und schließt alle Ausgabefenster des Knotens.
	\add \verb!public void ViewLoaded()! \\
	Eventhandler, um \name{ViewPositionChanged} initial zu triggern.
\end{itemize}

\paragraph{\name{NodeType}}
\begin{itemize}
	\add \verb!public string Name { get; set; }! \\
	Name des Knotens, der lesbarer ist als der reine Typname.
\end{itemize}

\paragraph{\name{PipelineViewModel}}
\begin{itemize}
	\add \verb!public EdgeViewModel DraggedEdge { get; }! \\
	Die gerade gezogene Kante, sonst null.
	\add \verb!public void CheckClearance(IDragEventInfo e)! \\
	Verhindert das Droppen eines Knoten, falls die Pipeline abgespielt wird.
	\change \verb!public void Drop(IDragEventInfo e)! \\
	Der Parametertyp wurde von WPFs \verb!DragEventArgs! auf das eigens kreierte Interface \name{IDragEventInfo} geändert, da ersterer Typ nicht mockbar ist.
	\add \begin{verbatim}
public void InOutputMouseDown(InOutputViewModel inOut)
public void InOutputMouseMove(InOutputViewModel inOut, RoutedEventArgs e)
public void InOutputMouseUp(InOutputViewModel inOut)
public void MouseMove(IMouseEventInfo e)
public void MouseUp()
public void NodeMouseDown(NodeViewModel inOut, IMouseEventInfo e)
	\end{verbatim}
	Eventhandler für Drag \& Drop
\end{itemize}

\paragraph{\name{ReplayStateViewModel}}
\begin{itemize}
	\change \verb!public bool IsPlaying { get; set; }! \\
	Der Setter wurde \verb!public! gemacht, damit das \name{MainViewModel} beim Laden einer Pipeline die Wiedergabe stoppen kann.
\end{itemize}

\paragraph{\name{VideoOutputViewModel}}
\begin{itemize}
	\add \verb!public WriteableBitmap SourceImage { get; }! \\
	Speichert das Bild, das als nächstes in das Ausgabefenster gezeichnet werden soll.
\end{itemize}


\subsection{\name{YuvKA.ViewModel.Implementation}}

\paragraph{HistogramViewModel}
\begin{itemize}
	\add \verb!public EnumerableDataSource<KeyValuePair<int, double>> Data { get; private set; }! \\
	Ruft die Analysedaten des Histogrammes ab oder setzt diese fest.
\end{itemize}

\paragraph{DiagramViewModel}
\begin{itemize}
	\add \verb!public ObservableCollection<LineGraphViewModel> LineGraphs { get; }! \\
	Ruft die Kurven im Diagramm ab, die den Graphen des Dieagrammknotens entsprechen. 
	\add \verb!public Tuple<string, Node.Input> Reference { get; set; }! \\
	Ruft das Referenzvideo des Diagrammknotens ab oder setzt diese fest.
	\add \verb!public ObservableCollection<Tuple<string, Node.Input>> Videos { get; }! \\
	Ruft die Eingabevideos des Diagrammknotens ab und fügt diesen einen Index hinzu.
	\add \verb!public public Tuple<string, Node.Input> ChosenVideo { get; set; }! \\
	Ruft das aktuell vom Benutzer zur Analyse ausgewählte Video ab oder setzt dieses fest.
	\add \verb!public ObservableCollection<GraphControl> GraphControls { get; set; }! \\
	Ruft die Grapheneinstellungen ab oder setzt diese fest.
	\add \verb!public List<Color> LineColors { get; set; }! \\
	Ruft die zur Zeichnung schon verwendeten Farben ab oder setzt diese fest.
	\add \verb!public List<System.Windows.Media.Color> TypeColors { get; }! \\
	Ruft die Basisfarben der einzelnen Graphtypen ab, von denen dann die einzelnen, zur Zeichnung verwendeten Farben abgeleitet werden.
	\change \verb!public IEnumerable<Tuple<string, IGraphType>> Types { get; set; }! \\
	Den Diagrammtypen wird nun ein Name hinzugefügt, damit dieser in der GUI angezeigt werden kann.
	\add \verb!public static bool IsInIntervall(double intervallCenter, double number, double intervallSize)! \\
	Entscheidet, ob eine Zahl in einem Intervall liegt.
	\add \verb!public void DeleteGraphControl(GraphControl graphControl)! \\
	Löscht eine gegebene Grapheneinstellung sowie deren Graph und dessen Kurve.
	\add \verb!public override void Handle(TickRenderedMessage message)! \\
	Aktualisiert jede Kurve mit den jewiligen Daten eines Frames, sobald dieser berechnet wurde.
	\change \verb!public void AddGraph(GraphControl graphControl)! \\
	Fügt eine Graphen und dessen Kurve hinzu, der aus der gegebenen Grapheneinstellung abgerufen wurde.
	\add \verb!public void AddLineGraphViewModel(GraphControl graphControl)! \\
	Fügt eine Kurve zum Diagramm hinzu, welche aus der gegebenen Grapheneinstellung und deren Graph berechnet wurde.
	\add \verb!public void AddGraphControl()! \\
	Fügt dem Diagrammknoten eine neue Grapheneinstellung hinzu.
	\remove \verb!DeleteGraph! \\
	Diese Methode wird von einer entsprechenden Methode der GraphControl-Klasse übernommen.
\end{itemize}

\paragraph{+ GraphControl}~\\
\name{GraphControl} verwaltet die vom Benutzer vorgenommenen Einstellungen an einem Graphen.
\begin{itemize}
	\add \verb!public DiagramViewModel Parent { get; set; }! \\
	Ruft das DiagramViewModel, zu dem diese Grapheneinstellung gehört, ab oder setzt es fest.
	\add \verb!public Tuple<string, Node.Input> Video { get; set; }! \\
	Ruft das Video ab oder setzt es fest.
	\add \verb!public DiagramGraph Graph { get; set; }! \\
	Ruft den Diagrammgraphen ab oder setzt ihn fest.
	\add \verb!public ObservableCollection<Tuple<string, IGraphType>> Types { get; set; }! \\
	Ruft das alle verfügbaren Graphentypen ab oder setzt diese fest.
	\add \verb!public ObservableCollection<Tuple<string, IGraphType>> DisplayTypes { get; set; }! \\
	Ruft die mit den momentanen Einstellungen verfügbaren Graphentypen ab oder setzt sie fest.
	\add \verb!public Tuple<string, IGraphType> ChosenType! \\
	Ruft den momentan vom Benutzer gewählten Graphentypen ab oder setzt ihn fest.
	\add \verb!public System.Drawing.Color CurrentLineColor { get; set; }! \\
	Ruft die momentan verwendete Farbe für die Kurve ab oder setzt sie fest. Benutzt hierfür die System.Drawing.Color-Klasse.
	\add \verb!public Color LineColor { get; set; }! \\
	Ruft die momentan verwendete Farbe für die Kurve ab oder setzt sie fest. Benutzt hierfür die System.Windows.Media.Color-Klasse.
	\add \verb!public bool ReferenceSet { get; set; }! \\
	Ruft ab oder setzt fest, ob momentan ein Referenzvideo ausgewählt ist.
	\add \verb!public bool ReferenceHasLogfile { get; set; }! \\
	Ruft ab oder setzt fest, ob das Referenzvideo ein Logfile hat.
	\add \verb!public SolidColorBrush GraphColor { get; set; }! \\
	Ruft die Farbe für die Vorschau der Kurve ab oder setzt sie fest.
	\add \verb!public void SetLineColor()! \\
	Setzt jeweils die Farben für die verschiedenen Color-Properties fest.
	\add \verb!public Color NewColor(Tuple<string, IGraphType> type)! \\
	Generiert eine neue Farbe vom selben Farbon wie die Basisfarbe des gegebenen Graphentypen.
	\add \verb!public void SetDisplayTypes()! \\
	Entscheidet, welche Graphentypen mit den momentanen Einstellungen verfügbar sind und legt diese fest.
\end{itemize}

\paragraph{+ LineGraphViewModel}~\\
\name{LineGraphViewModel} repräsentiert eine Kurve in einem Diagramm eines DiagramViewModels.
\begin{itemize}
	\add \verb!public CompositeDataSource PointDataSource { get; set; }! \\
	Ruft die Datenquelle der Kurve ab oder setzt sie fest.
	\add \verb!public string Name { get; set; }! \\
	Ruft den Namen der Kurve ab oder setzt ihn fest.
	\add \verb!public Color Color { get; set; }! \\
	Ruft die Farbe der Kurve ab oder setzt sie fest.
	\add \verb!public Guid EntityId { get; set; }! \\
	Ruft die ID der Kurve ab oder setzt sie fest.
	\add \verb!public bool LineAndMarker { get; set; }! \\
	Ruft ab oder setzt fest, ob die Punkte der Kurve angezeigt werden sollen.
	\add \verb!public int Thickness { get; set; }! \\
	Ruft die Dicke der Linie der Kurve ab oder setzt sie fest.
\end{itemize}

\paragraph{+ HslHelper}~\\
\name{HslHelper} enthält eine Methode zur Konvertierung zwischen dem HSL - und dem RGB - Farbraum, sodass sie von mehreren Klassen verwendet werden kann.
\begin{itemize}
	\add \verb!public static Color HslToRgb(double h, double s, double l)! \\
	Konvertiert eine Farbe vom HSL-Farbraum zum RGB-Farbraum.
\end{itemize}

\paragraph{\name OverlayViewModel}
\begin{itemize}
	\add \verb!public System.Tuple<string, IOverlayType> ChosenType! \\
	Ein Tupel, welches den Namen und den Typ des gerade verwendeten Überlagerungstyps.
	\add \verb!public WriteableBitmap RenderedImage { get; private set; }! \\
	Das Ergebnis der Überlagerung für die \name{View} aufbereitet. Dies ist notwendig, da die die \name{View} eine \name{Frame} nicht ohne weiteres darstellen kann.
	\add \verb!public IEnumerable<System.Tuple<string, IOverlayType>> TypeTuples! \\
	Eine Sammlung aller momentan verfügbaren Überlagerungstypen in Form von Tupeln mit Namen und Typ. Dies ist notwendig für die \name{View} um die Auswahl der Überlagerungen darzustellen.
\end{itemize}

\subsection{\name{YuvKA.ViewModel.PropertyEditor}}

\paragraph{\name PropertyViewModel}
\begin{itemize}
	\add \verb!public string DisplayName { get; }! \\
	Dies gibt das Name-Attribut der Property bzw. den Namen der Property weiter. Dies ist notwendig um der \name{View} deskriptivere Namen der Properties bereitzustellen.
	\add \verb!public void CommitChange()! \\
	Diese Methode benachrichtigt alle anderen Objekte dass sich diese Property geändert. Dies ist notwendig damit sich die \name{View} aktualisieren kann, sobald sich der Wert einer Property ändert.
	\add \verb!public void Initialize(object source, PropertyDescriptor property)! \\
	Diese Methode weist, einem PropertyViewModel eine Property und die Quelle der Property zur Verwaltung zu. Dies ist notwendig da das PropertyViewModel einen Argumentlosen Konstruktor benötigt und nur auf diese Weise sicherstellen lässt, dass die Property und deren Quelle immer gemeinsam gesetzt werden.
\end{itemize}

\paragraph{\name {PropertyViewModel<T>}}
\begin{itemize}
	\change \verb!public T TypedValue { get; set; }! \\
	Der typisierte Wert der Property wurde umbenannt, um Namenskonflikte mit dem untypisierten Wert der Property der Oberklasse zu vermeiden.
\end{itemize}