\subsection{\name{YuvKA.VideoModel}}

\paragraph{\name{Frame}}
\begin{itemize}
	\add \verb!public GetPixelOrBlack(int x, int y)! \\
	Neue öffentliche Methode, die es erleichtern soll, auf die Farbwerte innerhalb eines Frames zuzugreifen, ohne beachten zu müssen, ob die gegebenen Koordinaten tatsächlich innerhalb des \name{Frame} liegen. Falls ja, so wird der entsprechende Pixel an Stelle (x, y) als \name{Rgb}-Objekt zurückgegeben. Falls nicht, so wird ein schwarzer Farbwert für den Pixel zurückgegeben.
	\add \verb!public MaxBoundaries(Frame[] frames)! \\
	Neue öffentliche Methode, welche aus einem Array von Frames jeweils das Maximum der Breite und der Höhe findet und ein \name{Size}-Objekt zurückgibt mit \name{height}- bzw. \name{width}-Wert, welcher alle gegebenen Frames umfasst.
\end{itemize}

\paragraph{\name{MacroblockDecision}}
\begin{itemize}
	\change \verb!public Vector Movement { get; set; }! \\
	Die \name{Movement}-property wurde schreibbar gemacht, da eine korrekte Initialisierung sonst nicht möglich wäre.
	\change \verb!public MacroblockPartitioning? Partitiondecision { get; set; }! \\
	Die \name{Partitiondecision}-property wurde schreibbar gemacht, da eine korrekte Initialisierung sonst nicht möglich wäre.
\end{itemize}

\paragraph{\name{Rgb}}
\begin{itemize}
	\change \verb!public byte R { get; private set; }! \\
	Der setter der R-Property wurde auf private gesetzt.
	\change \verb!public byte G { get; private set; }! \\
	Der setter der G-Property wurde auf private gesetzt.
	\change \verb!public byte B { get; private set; }! \\
	Der setter der B-Property wurde auf private gesetzt.
\end{itemize}

\paragraph{\name{YuvEncoder}}
\begin{itemize}
	\add \verb!public static Video Decode(int width, int height, string filename, string logFileName = null, string motionVectorFileName = null)! \\
	Neuer Parameter \verb!string motionVectorFileName = null!: Die an ein Video gebundenen Bewegungsvektoren sollen schon beim Lesen eines Videos vom Hintergrundspeicher gelesen werden, da \name{Video}-Obekte unveränderlich sind, und bei Neuwahl der entsprechenden Datei ein neues Video-Objekt erstellt werden muss.
	\add \verb!public static void Encode(Stream stream, IEnumerable<Frame> frames)! \\
	Neue öffentliche statische Methode Encode, welche als Parameter einen Stream entgegennimmt. Dies ermöglicht es, zu Testzwecken auch in einen \name{MemoryStream} zu schreiben, was den Hintergrundspeicher nicht belastet und in der Regel schneller ist.
\end{itemize}

\paragraph{\name{YuvEncoder.Video}}
\begin{itemize}
	\remove \verb!public void Dispose()! \\
	Da keine Streams länger als unbedingt nötig offen gehalten werden, ist die zuvor von der \name{Video}-Klasse implementierte Schnittstelle \name{IDisposable} hier nicht mehr benötigt. Dadurch entfällt diese Methode.
\end{itemize}


\subsection{\name{YuvKA.Pipeline}}

\paragraph{\name{PipelineDriver}}
\begin{itemize}
	\change Die Klasse ist nicht mehr als statisch deklariert. Diese Änderung ermöglicht, verschiedene Graphen parallel zu berechnen, indem jeweils ein Driver instanziert wird, die einzelnen Berechnungen aber weiterhin den Parallelitätszusicherungen genügen.
	\add \verb!public IObservable<IDictionary<Node.Output, Frame>> RenderTicks(IEnumerable<Node> startNodes, int startTick = 0, int? tickCount = null, CancellationToken? token = null)! \\
	Neuer Parameter \verb!int? tickCount = null!: Wie sich herausstellte, sollte die Berechnung der Pipeline nicht nur durch ein \name{CancellationToken} jederzeit abbrechbar sein, sondern auch von sich aus nach einer gegebenen Anzahl Ticks, nämlich bis zum Ende des gegebenen Eingabevideos, enden können. Existiert kein Eingabevideo, kann dem Parameter \name{null} zugewiesen werden (der Standardwert), um weiterhin bis zu einem manuellen Abbruch zu berechnen.
\end{itemize}

\paragraph{\name{PipelineGraph}}
\begin{itemize}
	\change \verb!public int? TickCount { get; }! \\
	Die Property ist nun ein nullable int, da der Wert Null verwendet wird, um eine unbegrenzte Videolänge zu signalisieren.
	\add \verb!public void AddNode(Node node)! \\
	Diese Erweiterung ermöglicht es beim Hinzufügen eines Knoten diesem einen eindeutigen Namen aus der Folge Defaultname, Defaultname 2, Defaultname 3, ... zuzuordnen. Dieser Name kann nun verwendet werden, um ihn im Knoten selbst und allen seinen zugehörigen Outputfenstern anzuzeigen. Hiermit steht dem Benutzer eine leiche erkennbare eindeutige Zuordnung zur Verfügung. Weiterhin sollten auf keine andere Weise Knoten zum Graphen hinzugefügt werden.
	\add \verb!public bool CanAddEdge(Node source, Node sink)! \\
	Die Abfrage, ob eine Kante legal ist, ohne sie auch hinzuzufügen, ermöglicht es, Kanten in der GUI schon vor dem Drop-Event als legal oder illegal zu markieren.
	\add \verb!public int NumberOfFramesToPrecompute(IEnumerable<Node> outputNodes)! \\
	Da es möglich sein soll in der Pipeline zu springen und es Knoten gibt, die den aktuellen Frame aus vergangenen Ticks berechnen, muss hierzu errechnet werden wie viele Ticks vorberechnet werden sollen.
	\add \verb!public void RemoveNode(Node node)! \\
	Es stellte sich heraus, dass beim Entfernen eines Knoten aus dem Graphen auch alle zugehörigen Kanten entfernt werden müssen. Diese neue Methode ermöglicht dies.
\end{itemize}

\paragraph{\name{PipelineState}}
\begin{itemize}
	\add \verb!public int ActualSpeed { get; }! \\
	Besonders zu Debugzwecken und zur Demonstration wurde diese Property hinzugefügt, um die tatsächlich gemessene Abarbeitungsgeschwindigkeit in der UI anzeigen zu können.
	\add \verb!public PipelineDriver Driver { get; }! \\
	Nachdem in der \name{PipelineDriver}-Klasse der \name{static}-Modifier entfernt wurde, musste mit dieser neuen Property der Pipeline eine Driver-Instanz zugeordnet werden.
\end{itemize}


\subsection{\name{YuvKA.Pipeline.Implementation}}

\paragraph{\name{NoiseInputNode}}
\begin{itemize}
	\add \verb!public double? Scale { get; set; }! \\
	Diese neu eingeführte Option erlaubt es dem Benutzer den angezeigten Perlin Noise zu skalieren.
	\add \verb!public double? Speed { get; set; }! \\
	Diese neu eingeführte Option erlaubt es dem Benutzer die Geschwindigkeit des angezeigten Perlin Noise einzustellen.
\end{itemize}

Desweiteren wurden zwei neue Arten von Noise eingeführt, die Abwandlungen der schon existierenden sind (siehe \name{NoiseType}).

\paragraph{\name{NoiseType}}
\begin{itemize}
	\add \verb!ColoredCoherent! \\
	Erstellt farbigen Coherent Noise.
	\add \verb!ColoredPerlin! \\
	Erstellt farbigen Perlin Noise.
\end{itemize}


\subsection{\name{YuvKA.ViewModel}}

Wie erwartet hat sich im Viewmodel eine große Zahl an Änderungen ergeben, die zum Großteil aus dem Hinzufügen neuer Properties bestehen. Dies ist besonders der Tatsache geschuldet, dass das Viewmodel nicht wirklich Teil der grundlegenden Architektur sondern vielmehr Verknüpfungsschicht des Models und der View ist, wobei die Architektur letztgenannter Schicht, nämlich WPF, bereits gegeben war und wegen ihres unglaublichen Umfangs im Detail erst während der Implementierung Fall für Fall exakt erkundet werden konnte. Deshalb werden im Weiteren die Änderungen beschrieben, ohne einzeln auf die Gründe einzugehen, warum von der Entwurfsarchitektur abgewichen wurde.

\paragraph{\name{EdgeViewModel}}
\begin{itemize}
	\add \verb!public InOutputViewModel StartViewModel { get; set; }! \\
	     \verb!public InOutputViewModel EndViewModel { get; set; }! \\
	Legt Anfang bzw. Ende der Kante auf einen Ein-/Ausgang fest. Nach Setzen der Properties werden Start- bzw. Endpunkt der Kante automatisch entsprechend aktualisiert.
	\add \begin{verbatim}public EdgeStatus Status { get; set; }
	enum EdgeStatus { Indeterminate, Invalid, Valid }
	\end{verbatim}
	Gibt während des Ziehens einer Kante ihren Zustand an, der in der View durch die Linienfarben schwarz/rot/grün visualisiert wird.
	\add \verb!public void Dispose()! \\
	Entfernt alle Abonnements von Positionsänderungen der verbundenen Knoten, um Speicherlecks zu verhindern.
\end{itemize}

\paragraph{\name{+ InOutputViewModel}}~\\
\name{InOutputViewModel} ist eine gemeinsames View Model für Inputs und Outputs.
\begin{itemize}
	\add \verb!public bool IsFake { get; }! \\
	Fake-Eingänge sind solche ohne zugrundeliegendes Model. Sie werden für das dynamische Hinzufügen von Eingängen benötigt.
	\add \verb!public IObservable<Point> Midpoint { get; }! \\
	Gibt den gerade jeweils aktuellen Mittelpunkt des Ein-/Ausgangs zurück.
	\add \verb!public object Model { get; }! \\
	Der zugrundeliegende Input oder Output
	\add \verb!public NodeViewModel Parent { get; }! \\
	Das View Model des Knotens dieses Ein-/Ausgangs
\end{itemize}

\paragraph{\name{PipelineViewModel}}
\begin{itemize}
	\add \verb!public EdgeViewModel DraggedEdge { get; }! \\
	Die gerade gezogene Kante, sonst null.
	\add \verb!public void CheckClearance(IDragEventInfo e)! \\
	Verhindert das Droppen eines Knoten, falls die Pipeline abgespielt wird.
	\change \verb!public void Drop(IDragEventInfo e)! \\
	Der Parametertyp wurde von WPFs \verb!DragEventArgs! auf die eigens kreierte Klasse \name{IDragEventInfo} geändert, da erstere Klasse nicht mockbar ist.
	\add \begin{verbatim}
public void InOutputMouseDown(InOutputViewModel inOut)
public void InOutputMouseMove(InOutputViewModel inOut, RoutedEventArgs e)
public void InOutputMouseUp(InOutputViewModel inOut)
public void MouseMove(IMouseEventInfo e)
public void MouseUp()
public void NodeMouseDown(NodeViewModel inOut, IMouseEventInfo e)
	\end{verbatim}
	Eventhandler für Drag \& Drop
\end{itemize}

\paragraph{\name{VideoOutputViewModel}}
\begin{itemize}
	\add \verb!public WriteableBitmap SourceImage { get; }! \\
	Speichert das Bild, das als nächstes in das Ausgabefenster gezeichnet werden soll.
\end{itemize}


\subsection{\name{YuvKA.ViewModel.PropertyEditor}}
